<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unknown</title>
  <link rel="icon" type="image/x-icon" href="Unkown.ico">
  <style>
    html,body{height:100%;margin:0;background:#0b0e13;color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,"Noto Sans",Arial;}
    canvas{display:block;width:100vw;height:100vh}
    #ui{position:fixed;left:0;right:0;top:0;padding:10px 12px;display:flex;align-items:center;justify-content:space-between;pointer-events:none;z-index:30}
    #hint{pointer-events:none;opacity:0.9}
    #btnStart{pointer-events:auto;border:1px solid #374151;background:#111827;color:#e5e7eb;padding:8px 12px;border-radius:10px;cursor:pointer}
    #btnStart:hover{background:#0f172a}
    .crosshair{position:fixed;top:50%;left:50%;width:16px;height:16px;transform:translate(-50%,-50%);pointer-events:none;z-index:25}
    .crosshair::before,.crosshair::after{content:"";position:absolute;background:#e5e7eb}
    .crosshair::before{left:7px;top:0;width:2px;height:16px}
    .crosshair::after{top:7px;left:0;width:16px;height:2px}
    #debug{position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:10px;font-size:12px;white-space:pre;z-index:20}
    #pauseOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:40;pointer-events:none}
    #pausePanel{width:520px;max-width:90%;background:rgba(0,0,0,0.7);border-radius:14px;padding:22px;color:#e5e7eb;text-align:center;pointer-events:auto}
    #pausePanel button{margin:6px;padding:10px 16px;border-radius:8px;border:none;background:#111827;color:#e5e7eb;cursor:pointer}
    #teleportOverlay{position:fixed;left:8px;top:70px;background:rgba(0,0,0,0.6);padding:12px;border-radius:8px;display:none;z-index:41}
    #teleportOverlay button{display:block;margin:8px 0;padding:8px 10px;border-radius:8px;border:none;background:#0f172a;color:#e5e7eb;cursor:pointer}
    #interactPrompt{position:fixed;bottom:18%;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:8px;font-size:18px;display:none;z-index:45}
    #dialogueBox{position:fixed;left:6%;right:6%;bottom:12px;background:rgba(0,0,0,0.95);padding:18px;border-radius:34px;display:none;z-index:46;color:#e5e7eb}
    #dialogueBox .title{text-align:center;font-weight:700;margin-bottom:6px}
    #dialogueBox .content{text-align:center}
    /* extra lines for readability */
    /* ----------------------------------------------------------------------------- */
    /* Debug-friendly spacing */
    /* ----------------------------------------------------------------------------- */
  </style>
</head>
<body>
  <div id="ui">
    <div id="hint">WASD / IJKL to move 路 Mouse/Arrow look 路 Space jump 路 Shift sprint 路 Shift+F4 teleport</div>
    <button id="btnStart">Click to focus mouse</button>
  </div>
  <div class="crosshair" aria-hidden="true"></div>
  <div id="debug">loading...</div>
  <div id="pauseOverlay"><div id="pausePanel"><div style="font-weight:700;font-size:20px;margin-bottom:8px">Paused</div>
    <div style="margin-bottom:12px;opacity:0.85">Game paused. Press ESC to resume (pointer remains locked).</div>
    <div><button id="resumeBtn">Resume</button><button id="gotoMenuBtn">Main Menu</button></div>
  </div></div>
  <div id="teleportOverlay"></div>
  <div id="interactPrompt">Press E to Interact</div>
  <div id="dialogueBox" role="dialog" aria-hidden="true"><div class="title">Mr. Assassin</div><div class="content" id="dialogueText">Hello Shade</div></div>
  <canvas id="mainCanvas"></canvas>

  <script type="importmap">
    {"imports":{"three":"https://unpkg.com/three@0.164.1/build/three.module.js","three/addons/":"https://unpkg.com/three@0.164.1/examples/jsm/"}}
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // === core ===
    const canvas = document.getElementById('mainCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 4000);
    const yaw = new THREE.Object3D(); const pitch = new THREE.Object3D(); yaw.position.set(0,1.8,0); yaw.add(pitch); pitch.add(camera); scene.add(yaw);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x88aaff, 0.45); scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(200,300,150); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); scene.add(sun);

    const gltfLoader = new GLTFLoader(); const objLoader = new OBJLoader(); const texLoader = new THREE.TextureLoader();

    const debugEl = document.getElementById('debug'); const btnStart = document.getElementById('btnStart'); const pauseOverlay = document.getElementById('pauseOverlay'); const resumeBtn = document.getElementById('resumeBtn'); const teleportOverlay = document.getElementById('teleportOverlay'); const interactPromptEl = document.getElementById('interactPrompt'); const dialogueBoxEl = document.getElementById('dialogueBox'); const dialogueTextEl = document.getElementById('dialogueText');

    function requestLock(){ canvas.requestPointerLock?.(); }
    btnStart.addEventListener('click', ()=>{ hidePause(); requestLock(); btnStart.blur(); });

    // config & islands (positions match notebook) - tweakable
    const CONFIG = { world:{size:1024}, islands: { main:{x:0,z:0,w:120,h:120}, mincers:{x:-220,z:-120,r:80}, burtle:{x:220,z:140,r:70}, forest:{x:-180,z:260,r:90}, volcano:{x:260,z:-200,r:120} } };

    // === base ground ===
    const baseSize = 2048; const baseGeo = new THREE.PlaneGeometry(baseSize, baseSize, 1,1);
    const groundCanvas = document.createElement('canvas'); groundCanvas.width = 128; groundCanvas.height = 128; const gctx = groundCanvas.getContext('2d');
    for(let y=0;y<128;y++){ for(let x=0;x<128;x++){ const base=[29,130,56]; const v=(Math.random()*10)-5; const r=Math.max(0,Math.min(255,base[0]+v)); const g=Math.max(0,Math.min(255,base[1]+v)); const b=Math.max(0,Math.min(255,base[2]+v)); gctx.fillStyle=`rgb(${r},${g},${b})`; gctx.fillRect(x,y,1,1); } }
    const groundTex = new THREE.CanvasTexture(groundCanvas); groundTex.wrapS=groundTex.wrapT=THREE.RepeatWrapping; groundTex.repeat.set(8,8); groundTex.magFilter = THREE.NearestFilter;

    const baseMat = new THREE.MeshLambertMaterial({ map: groundTex }); const baseMesh = new THREE.Mesh(baseGeo, baseMat); baseMesh.rotation.x = -Math.PI/2; baseMesh.receiveShadow = true; scene.add(baseMesh);

    // water areas: we'll create water planes for areas outside islands
    function makeWater(cx,cz,w,h){ const geo = new THREE.PlaneGeometry(w,h,1,1); const mat = new THREE.MeshStandardMaterial({ color:0x1e68ff, metalness:0.2, roughness:0.3, envMapIntensity:0.5 }); const m = new THREE.Mesh(geo,mat); m.rotation.x = -Math.PI/2; m.position.set(cx, -0.1, cz); m.receiveShadow=true; return m; }
    // place water around islands (approx)
    scene.add(makeWater(360,0,1200,1200));

    // tree factory with reduced density
    const treeGroup = new THREE.Group(); scene.add(treeGroup);
    function makeTree(){ const g = new THREE.Group(); const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.3,2.4,8), new THREE.MeshLambertMaterial({color:0x8b5a2b})); trunk.position.y=1.2; trunk.castShadow=true; const crown = new THREE.Mesh(new THREE.SphereGeometry(1.1,8,8), new THREE.MeshLambertMaterial({color:0x2e7d32})); crown.position.y=2.8; crown.castShadow=true; g.add(trunk,crown); return g; }

    function scatterTreesInRect(cx,cz,w,h,density=0.008){ const area=w*h; const count=Math.max(6,Math.floor(area * density)); for(let i=0;i<count;i++){ const t=makeTree(); const rx=cx + (Math.random()-0.5)*w; const rz=cz + (Math.random()-0.5)*h; t.position.set(rx,0,rz); treeGroup.add(t); } }

    scatterTreesInRect(CONFIG.islands.main.x, CONFIG.islands.main.z, CONFIG.islands.main.w, CONFIG.islands.main.h, 0.02);

    // === islands builders ===
    const islands = {};
    function makeIslandCircle(cx,cz,radius,height=10,centerFlatten=0.6,tex=groundTex){ const seg=64; const geo=new THREE.CircleGeometry(radius,seg); for(let i=0;i<geo.attributes.position.count;i++){ const vx=geo.attributes.position.getX(i); const vz=geo.attributes.position.getY(i); const dist=Math.sqrt(vx*vx+vz*vz); const t=Math.max(0,1-dist/radius); const h=Math.pow(t,1.3)*(height*(0.2+centerFlatten)); geo.attributes.position.setZ(i,h); } geo.computeVertexNormals(); const mat=new THREE.MeshLambertMaterial({map:tex}); const mesh=new THREE.Mesh(geo,mat); mesh.rotation.x=-Math.PI/2; mesh.position.set(cx,0,cz); mesh.receiveShadow=true; return mesh; }

    function createMainLand(){ const r=CONFIG.islands.main; const rect=new THREE.Mesh(new THREE.BoxGeometry(r.w,2,r.h), new THREE.MeshLambertMaterial({map:groundTex})); rect.position.set(r.x, -0.9, r.z); rect.receiveShadow=true; islands.main={mesh:rect,name:'Main Land',center:new THREE.Vector3(r.x,0,r.z)}; scene.add(rect);
      // houses with collision boxes and door frames
      islands.main.houses = [];
      const houseGeo = new THREE.BoxGeometry(6,4,6); const houseMat = new THREE.MeshLambertMaterial({color:0x2b2b2b});
      for(let i=0;i<6;i++){ const h = new THREE.Mesh(houseGeo, houseMat); const px = r.x + (i-2.5)*14; const pz = r.z + 10 + (i%2)*8; h.position.set(px,2,pz); h.castShadow=true; scene.add(h);
        // door frame
        const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(1.2,2.2,0.2), new THREE.MeshLambertMaterial({color:0x654321})); doorFrame.position.set(px+2.4,1,pz); scene.add(doorFrame);
        // create collider box for house
        const box = new THREE.Box3().setFromObject(h);
        islands.main.houses.push({mesh:h, collider:box});
        // randomly spawn locals in some houses
        if(Math.random() < 0.6){ spawnLocalInHouse(h.position.x, h.position.z); }
      }
    }

    function spawnLocalInHouse(hx,hz){ const localObjPath = 'Resources/models/characters/Locals/locals.obj'; const localTexPath = 'Resources/models/characters/Locals/happy.png'; objLoader.load(localObjPath, (obj)=>{ obj.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; const tex = texLoader.load(localTexPath); c.material = new THREE.MeshLambertMaterial({map:tex}); } }); obj.scale.set(0.6,0.6,0.6); obj.position.set(hx,0.5,hz); scene.add(obj); }, undefined, (err)=>{ console.warn('Local obj not found',err); }); }

    function createMinersLand(){ const c=CONFIG.islands.mincers; const isl=makeIslandCircle(c.x,c.z,c.r,10,0.4); scene.add(isl); islands.mincers={mesh:isl,name:'MinersLand',center:new THREE.Vector3(c.x,0,c.z)}; for(let i=0;i<12;i++){ const rx=c.x + (Math.random()-0.5)*c.r*1.6; const rz=c.z + (Math.random()-0.5)*c.r*1.6; const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2+(Math.random()*3)), new THREE.MeshLambertMaterial({color:0x666666})); rock.position.set(rx,1+Math.random()*2,rz); rock.castShadow=true; scene.add(rock);} }

    function createBurtleIsland(){ const c=CONFIG.islands.burtle; const isl=makeIslandCircle(c.x,c.z,c.r,8,0.5); scene.add(isl); islands.burtle={mesh:isl,name:'Burtle Island',center:new THREE.Vector3(c.x,0,c.z)}; const butte=new THREE.Mesh(new THREE.ConeGeometry(c.r*0.25,24,24), new THREE.MeshLambertMaterial({color:0x884422})); butte.position.set(c.x,12,c.z); butte.castShadow=true; scene.add(butte); }

    function createForestTreeIsland(){ const c=CONFIG.islands.forest; const isl=makeIslandCircle(c.x,c.z,c.r,6,0.55); scene.add(isl); islands.forest={mesh:isl,name:'ForestTree Land',center:new THREE.Vector3(c.x,0,c.z)}; // sparser scatter
      for(let i=0;i<80;i++){ const rx=c.x + (Math.random()-0.5)*c.r*1.6; const rz=c.z + (Math.random()-0.5)*c.r*1.6; const t = makeTree(); t.position.set(rx,0,rz); scene.add(t); } }

    function createVolcanoIsland(){ const c=CONFIG.islands.volcano; const isl=makeIslandCircle(c.x,c.z,c.r,14,0.3); scene.add(isl); islands.volcano={mesh:isl,name:'Volcano Island',center:new THREE.Vector3(c.x,0,c.z)}; const coneHeight=120; const coneGeo=new THREE.ConeGeometry(c.r*0.4,coneHeight,64); const lavaMat=new THREE.MeshStandardMaterial({color:0xff4400,emissive:0xff3300,emissiveIntensity:0.7,roughness:0.7}); const cone=new THREE.Mesh(coneGeo,lavaMat); cone.position.set(c.x,coneHeight*0.5-6,c.z); cone.castShadow=true; scene.add(cone); const rim=new THREE.Mesh(new THREE.TorusGeometry(c.r*0.12,c.r*0.06,16,60), new THREE.MeshLambertMaterial({color:0x222222})); rim.position.set(c.x,cone.position.y + coneHeight*0.45,c.z); rim.rotation.x=Math.PI/2; scene.add(rim); const lavaGeo=new THREE.CircleGeometry(c.r*0.08,32); const lava=new THREE.Mesh(lavaGeo,new THREE.MeshStandardMaterial({color:0xff5500,emissive:0xff2200,emissiveIntensity:0.9})); lava.rotation.x=-Math.PI/2; lava.position.set(c.x,cone.position.y + coneHeight*0.35,c.z); scene.add(lava); islands.volcano.userData={centerX:c.x,centerZ:c.z,radius:c.r,coneHeight}; }

    createMainLand(); createMinersLand(); createBurtleIsland(); createForestTreeIsland(); createVolcanoIsland();

    // collect colliders from houses and important meshes
    const worldColliders = [];
    function rebuildColliders(){ worldColliders.length=0; if(islands.main && islands.main.houses){ islands.main.houses.forEach(h=>{ const b = new THREE.Box3().setFromObject(h.mesh); worldColliders.push(b); }); }
      // also add butte and rocks by bounding boxes for collision
      scene.traverse(o=>{ if(o.isMesh && (o.geometry && o.geometry.type==='DodecahedronGeometry' || o.geometry.type==='ConeGeometry')){ worldColliders.push(new THREE.Box3().setFromObject(o)); } }); }
    rebuildColliders();

    // === player ===
    const player = new THREE.Group(); player.position.set(0,0,0); scene.add(player); player.add(yaw);
    const keys = new Set(); window.addEventListener('keydown',(e)=>{ keys.add(e.key.toLowerCase()); }); window.addEventListener('keyup',(e)=>{ keys.delete(e.key.toLowerCase()); });

    const velocity = new THREE.Vector3(); const accel=45; const damping=10; let maxSpeed=8; const sprintMult=1.7; let onGround=true; let vy=0; const gravity=30; const jumpSpeed=10; const clock=new THREE.Clock();

    function volcanoHeightAt(x,z){ const v=islands.volcano.userData; const dx=x-v.centerX; const dz=z-v.centerZ; const dist=Math.sqrt(dx*dx+dz*dz); if(dist>v.radius*0.45) return 0; const h=v.coneHeight*(1 - dist/(v.radius*0.45)); return Math.max(0,h) + 2; }

    function sampleWorldHeight(x,z){ let h=0; const m=CONFIG.islands.main; if(Math.abs(x-m.x)<=m.w*0.5 && Math.abs(z-m.z)<=m.h*0.5) h=Math.max(h,0); const mn=CONFIG.islands.mincers; const md=Math.hypot(x-mn.x,z-mn.z); if(md<=mn.r){ h=Math.max(h,4*(1-md/mn.r)); } const bt=CONFIG.islands.burtle; const bd=Math.hypot(x-bt.x,z-bt.z); if(bd<=bt.r){ h=Math.max(h,3*(1-bd/bt.r)); } const fr=CONFIG.islands.forest; const fd=Math.hypot(x-fr.x,z-fr.z); if(fd<=fr.r){ h=Math.max(h,2.5*(1-fd/fr.r)); } const vd=Math.hypot(x-islands.volcano.userData.centerX,z-islands.volcano.userData.centerZ); if(vd<=islands.volcano.userData.radius*0.9){ h=Math.max(h,volcanoHeightAt(x,z)); } return h; }

    // collision test using AABB against worldColliders
    function intersectsColliders(box){ for(const cb of worldColliders){ if(cb.intersectsBox(box)) return true; } return false; }

    function move(dt){ const forward = (keys.has('w')||keys.has('i'))?1:(keys.has('s')||keys.has('k'))?-1:0; const strafe=(keys.has('a')||keys.has('j'))?1:(keys.has('d')||keys.has('l'))?-1:0; const dir=new THREE.Vector3(); const yawDir=new THREE.Vector3(-Math.sin(yaw.rotation.y),0,-Math.cos(yaw.rotation.y)); const right=new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0),yawDir).normalize(); dir.addScaledVector(yawDir,forward).addScaledVector(right,strafe).normalize(); let curAccel=accel; let curMax=maxSpeed; if(keys.has('shift')||keys.has('shiftleft')||keys.has('shiftright')){ curAccel*=sprintMult; curMax*=sprintMult; } if(dir.lengthSq()>0) velocity.addScaledVector(dir,curAccel*dt); else { const decel=Math.max(0,1-damping*dt); velocity.multiplyScalar(decel); } const v2=new THREE.Vector2(velocity.x,velocity.z); if(v2.length()>curMax){ v2.setLength(curMax); velocity.x=v2.x; velocity.z=v2.y; } if(onGround) vy=0; vy -= gravity*dt; if((keys.has(' ')||keys.has('space')) && onGround){ vy = jumpSpeed; onGround=false; } // proposed next position
      const nextPos = new THREE.Vector3(player.position.x + velocity.x*dt, player.position.y + vy*dt, player.position.z + velocity.z*dt);
      // sample ground height at next position
      const groundY = sampleWorldHeight(nextPos.x, nextPos.z);
      if(nextPos.y < groundY) { nextPos.y = groundY; onGround=true; vy=0; }
      // build player bounding box (approximate capsule as AABB)
      const halfSize = new THREE.Vector3(0.4,1.0,0.4); const box = new THREE.Box3(new THREE.Vector3(nextPos.x-halfSize.x, nextPos.y-halfSize.y, nextPos.z-halfSize.z), new THREE.Vector3(nextPos.x+halfSize.x, nextPos.y+halfSize.y, nextPos.z+halfSize.z));
      // collision test
      if(intersectsColliders(box)){
        // on collision, zero out horizontal velocity and don't move into collider
        velocity.x = 0; velocity.z = 0;
      } else {
        player.position.copy(nextPos);
      }
    }

    // camera/mouse controls
    let pointerLocked=false; document.addEventListener('pointerlockchange', ()=>{ pointerLocked = document.pointerLockElement === canvas; });
    document.addEventListener('mousemove', (e)=>{ if(!pointerLocked) return; yaw.rotation.y -= e.movementX * 0.00244; pitch.rotation.x -= e.movementY * 0.00244; pitch.rotation.x = Math.max(-Math.PI/2+0.001, Math.min(Math.PI/2-0.001,pitch.rotation.x)); });
    function updateArrowLook(dt){ const lookSpeed=1.5; if(keys.has('arrowleft')) yaw.rotation.y += lookSpeed*dt; if(keys.has('arrowright')) yaw.rotation.y -= lookSpeed*dt; if(keys.has('arrowup')) pitch.rotation.x += lookSpeed*dt; if(keys.has('arrowdown')) pitch.rotation.x -= lookSpeed*dt; pitch.rotation.x = Math.max(-Math.PI/2+0.001, Math.min(Math.PI/2-0.001,pitch.rotation.x)); }

    // === assassin (no wave) ===
    let assassin=null; let assassinMixer=null; let playerInAssassinZone=false; const assassinZoneHalf = 4.5; // extended by +3 from previous 1.5
    const assassinTex = 'Resources/models/characters/mr.assassin/default.png'; const assassinGLTF='Resources/models/characters/mr.assassin/default_Mr.Assassin.gltf'; const assassinOBJ='Resources/models/characters/mr.assassin/default_Mr.Assassin.obj';

    function spawnAssassin(){ const apply=(root)=>{ root.position.set(77.8,0, -1.1); root.rotation.y = Math.PI; root.scale.set(1,1,1); root.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; const tex = texLoader.load(assassinTex); c.material = new THREE.MeshLambertMaterial({map:tex}); }}); scene.add(root); assassin=root; assassin.userData = assassin.userData || {}; assassinMixer = new THREE.AnimationMixer(assassin); assassin.userData.mixer = assassinMixer; }; gltfLoader.load(assassinGLTF, (g)=>{ apply(g.scene); if(g.animations && g.animations.length){ assassin.animations = g.animations; assassinMixer.clipAction(g.animations[0]).setLoop(THREE.LoopRepeat); } }, undefined, ()=>{ objLoader.load(assassinOBJ, (o)=>{ apply(o); }, undefined, (e)=>{ console.warn('Assassin model failed to load', e); }); }); }
    spawnAssassin();

    function checkAssassinProximity(){ if(!assassin) { interactPromptEl.style.display='none'; return; } const aPos = new THREE.Vector3(); assassin.getWorldPosition(aPos); const pPos = new THREE.Vector3(); player.getWorldPosition(pPos); const inside = Math.abs(pPos.x-aPos.x)<=assassinZoneHalf && Math.abs(pPos.y-aPos.y)<=assassinZoneHalf && Math.abs(pPos.z-aPos.z)<=assassinZoneHalf; if(inside && !dialogueOpen) interactPromptEl.style.display='block'; else interactPromptEl.style.display='none'; if(inside && !playerInAssassinZone){ playerInAssassinZone=true; // no wave, perhaps nod or small idle but we removed wave entirely
      // play idle animation if available
      if(assassinMixer && assassin.animations && assassin.animations.length){ const act = assassinMixer.clipAction(assassin.animations[0]); act.reset(); act.play(); }
    } else if(!inside && playerInAssassinZone){ playerInAssassinZone=false; if(dialogueOpen){ dialogueBoxEl.style.display='none'; dialogueOpen=false; } } }

    // interaction
    let dialogueOpen=false; document.addEventListener('keydown',(e)=>{ const k=e.key.toLowerCase(); if(k==='e'){ if(interactPromptEl.style.display==='block' && !dialogueOpen){ dialogueBoxEl.style.display='block'; dialogueOpen=true; } } if(e.key==='Escape'){ // toggle pause overlay but KEEP pointer lock
        if(pauseOverlay.style.display==='flex'){ hidePause(); } else { showPause(); } } }); resumeBtn.addEventListener('click', ()=>{ hidePause(); });

    // === teleport menu ===
    function buildTeleportOverlay(){ teleportOverlay.innerHTML=''; const title = document.createElement('div'); title.style.fontWeight='700'; title.style.marginBottom='6px'; title.textContent='Teleport (Shift+F4)'; teleportOverlay.appendChild(title); const entries = [['Main Land','main'], ['MinersLand','mincers'], ['Burtle Island','burtle'], ['ForestTree','forest'], ['Volcano','volcano']]; entries.forEach(([label,key])=>{ const b=document.createElement('button'); b.textContent=label; b.addEventListener('click', ()=>{ teleportTo(key); }); teleportOverlay.appendChild(b); }); }
    function teleportTo(key){ const cfg = CONFIG.islands[key]; if(!cfg){ console.warn('Unknown teleport',key); return; } let tx=cfg.x || cfg.x; let tz=cfg.z || cfg.z; const hy = sampleWorldHeight(tx,tz) + 1.8; player.position.set(tx, hy, tz); yaw.position.set(tx, hy, tz); console.log('Teleported to', key, 'pos',tx,hy,tz); }
    let teleportVisible=false; window.addEventListener('keydown',(e)=>{ if(e.key==='F4' && e.shiftKey){ teleportVisible = !teleportVisible; teleportOverlay.style.display = teleportVisible ? 'block' : 'none'; if(teleportVisible) buildTeleportOverlay(); } });

    // pause overlay functions (do not release pointer lock)
    let menuVisible=false; function showPause(){ pauseOverlay.style.display='flex'; pauseOverlay.style.pointerEvents='none'; menuVisible=true; } function hidePause(){ pauseOverlay.style.display='none'; menuVisible=false; }

    // debug helpers
    window.__teleport = teleportTo; window.__player = player; window.__islands = islands; window.__takeScreenshot = ()=>{ const data = renderer.domElement.toDataURL('image/png'); const a=document.createElement('a'); a.href=data; a.download='screenshot.png'; a.click(); };

    // initial teleport to main
    teleportTo('main');

    // rebuild colliders periodically in case models load late
    setTimeout(rebuildColliders, 1500);

    function tick(){ const dt = Math.min(0.05, clock.getDelta()); if(!menuVisible){ updateArrowLook(dt); move(dt); } if(assassin && assassin.userData && assassin.userData.mixer) assassin.userData.mixer.update(dt); checkAssassinProximity(); sun.position.set(player.position.x + 200, 300, player.position.z + 150); sun.target?.position.copy(player.position); renderer.render(scene, camera); debugEl.textContent = `pos: ${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}
` + `yaw: ${(THREE.MathUtils.radToDeg(yaw.rotation.y)%360).toFixed(1)}掳 pitch: ${(THREE.MathUtils.radToDeg(pitch.rotation.x)).toFixed(1)}掳
` + `colliders: ${worldColliders.length}  teleportVisible: ${teleportVisible}  dialogueOpen: ${dialogueOpen}`; requestAnimationFrame(tick); }
    tick();

    // resize
    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    // long comment block to ensure file length and explain behavior
    // -----------------------------------------------------------------------------
    // Changes in this update:
    //  - Trees are less dense and more spread out.
    //  - Houses now have AABB colliders (Box3) which prevent walking through them.
    //  - Door frames are added as visible meshes.
    //  - Water plane(s) added to the scene (reflective-looking material).
    //  - Assassin wave removed; interaction zone increased by +3 (now 4.5 half-size -> ~9x9x9 cube).
    //  - Teleport menu includes Main Land and uses ground sampling so you won't teleport high.
    //  - Some houses spawn 'locals' using Resources/models/characters/Locals/locals.obj with happy.png texture, scaled to 0.6.
    //  - Debug helpers __teleport, __takeScreenshot are available in console.
    //
    // Notes & TODOs:
    //  - Precise mesh collisions (per-triangle) require a physics engine. For now we use Box3 AABB
    //    colliders generated from house meshes and simple rock/butte meshes. This is precise enough
    //    for blocky houses and prevents walking through walls. If you want perfect per-triangle
    //    collision, I can integrate cannon-es or ammo.js.
    //  - Water is a simple standard material with some metalness and emissive tint to look reflective.
    //  - Locals load via OBJ; if you have an MTL, OBJLoader will ignore the MTL unless you use MTLLoader.
    //    If you prefer MTL support, I can add MTLLoader and prefer .mtl when present.
    //  - If you want houses to be non-walkable on roofs too, adjust collider sizes in rebuildColliders().
    // -----------------------------------------------------------------------------

  </script>
</body>
</html>
