<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Unkown</title>
  <link rel="icon" type="image/x-icon" href="Unkown.ico">
  <style>
    html, body { height: 100%; margin: 0; background:#0b0e13; color:#e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; overflow:hidden; }
    #ui { position: fixed; top: 0; left: 0; right:0; display:flex; align-items:center; justify-content:space-between; padding: 10px 12px; pointer-events: none; z-index:5; }
    #hint { pointer-events: none; opacity: 0.9; }
    #btnStart { pointer-events: auto; border:1px solid #374151; background:#111827; color:#e5e7eb; padding:8px 12px; border-radius:10px; cursor:pointer; }
    #btnStart:hover { background:#0f172a; }
    .crosshair { position: fixed; top: 50%; left: 50%; width: 16px; height: 16px; transform: translate(-50%, -50%); pointer-events: none; z-index:5; }
    .crosshair::before, .crosshair::after { content: ""; position: absolute; background: #e5e7eb; }
    .crosshair::before { left: 7px; top: 0; width: 2px; height: 16px; }
    .crosshair::after { top: 7px; left: 0; width: 16px; height: 2px; }
    #debug { position: fixed; left: 10px; bottom: 10px; background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 10px; font-size: 12px; white-space: pre; pointer-events: none; z-index:5; }

    /* --- Menu Screen --- */
    #menuScreen {
      position: fixed;
      inset: 0;
      background: url("Resources/menus.png") center/cover no-repeat;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #menuScreen button {
      margin: 10px;
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background: rgba(17,24,39,0.8);
      color: #e5e7eb;
    }
    #menuScreen button:hover { background: rgba(31,41,55,0.9); }
  </style>
</head>
<body>
  <div id="ui">
    <div id="hint">WASD / IJKL to move · Mouse or Arrow Keys to look · Space to jump · Shift to sprint</div>
    <button id="btnStart">Click to focus mouse</button>
  </div>
  <div class="crosshair" aria-hidden="true"></div>
  <div id="debug"></div>

  <!-- Menu Screen -->
  <div id="menuScreen">
    <button id="btnResume">Continue</button>
    <button id="btnQuit">Quit</button>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

    // --- Basic Three.js setup ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

    const yaw = new THREE.Object3D();
    const pitch = new THREE.Object3D();
    yaw.position.set(0, 1.8, 0);
    yaw.add(pitch);
    pitch.add(camera);
    scene.add(yaw);

    // Lighting
    const hemi = new THREE.HemisphereLight(0xffffff, 0x88aaff, 0.4);
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(200, 300, 150);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    const objLoader = new OBJLoader();
    const mtlLoader = new MTLLoader();

    // --- Ground ---
    const groundSize = 512;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    for (let y = 0; y < 128; y++) {
      for (let x = 0; x < 128; x++) {
        const base = [29, 130, 56];
        const variation = (Math.random() * 20) - 10;
        const r = Math.max(0, Math.min(255, base[0] + variation));
        const g = Math.max(0, Math.min(255, base[1] + variation));
        const b = Math.max(0, Math.min(255, base[2] + variation));
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }
    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.NearestFilter;
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(groundSize / 16, groundSize / 16);
    const groundMat = new THREE.MeshLambertMaterial({ map: tex });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- Trees ---
    const treeParent = new THREE.Group();
    scene.add(treeParent);

    function createTree() {
      const dummy = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3, 8), new THREE.MeshLambertMaterial({ color: 0x8b5a2b }));
      trunk.position.y = 1.5;
      trunk.castShadow = true;
      const leaves = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 12), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
      leaves.position.y = 3.4;
      leaves.castShadow = true;
      dummy.add(trunk, leaves);
      return dummy;
    }

    function scatterTrees(proto) {
      const tileSize = 16;
      const step = tileSize * 2;
      const half = groundSize / 2;
      for (let x = -half + step/2; x < half; x += step) {
        for (let z = -half + step/2; z < half; z += step) {
          for (let i = 0; i < 2; i++) {
            const t = proto.clone();
            const jx = (Math.random() - 0.5) * (step * 0.6);
            const jz = (Math.random() - 0.5) * (step * 0.6);
            t.position.set(x + jx, 0, z + jz);
            treeParent.add(t);
          }
        }
      }
    }
    scatterTrees(createTree());

    // --- Player ---
    const player = new THREE.Group();
    player.position.set(0, 0, 0);
    scene.add(player);
    player.add(yaw);

    // --- Controls ---
    const keys = new Set();
    window.addEventListener('keydown', (e) => { keys.add(e.key.toLowerCase()); });
    window.addEventListener('keyup',   (e) => { keys.delete(e.key.toLowerCase()); });

    const velocity = new THREE.Vector3();
    const accel = 45;
    const damping = 10;
    const maxSpeed = 8;
    const sprintMult = 1.7; // sprint factor

    const btnStart = document.getElementById('btnStart');
    const debug = document.getElementById('debug');
    const menuScreen = document.getElementById('menuScreen');
    const btnResume = document.getElementById('btnResume');
    const btnQuit = document.getElementById('btnQuit');

    const MOUSE_BASE = 0.002;
    const minecraftSensitivity122 = MOUSE_BASE * (122 / 100);

    let pointerLocked = false;
    function requestLock() { renderer.domElement.requestPointerLock(); }

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === renderer.domElement;
    });

    btnStart.addEventListener('click', () => {
      hideMenu();
      requestLock();
      btnStart.blur();
    });

    document.addEventListener('mousemove', (e) => {
      if (!pointerLocked) return;
      yaw.rotation.y -= e.movementX * minecraftSensitivity122;
      pitch.rotation.x -= e.movementY * minecraftSensitivity122;
      pitch.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, pitch.rotation.x));
    });

    function updateArrowLook(dt) {
      const lookSpeed = 1.5;
      if (keys.has('arrowleft'))  yaw.rotation.y += lookSpeed * dt;
      if (keys.has('arrowright')) yaw.rotation.y -= lookSpeed * dt;
      if (keys.has('arrowdown'))    pitch.rotation.x -= lookSpeed * dt;
      if (keys.has('arrowup'))  pitch.rotation.x += lookSpeed * dt;
      pitch.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, pitch.rotation.x));
    }

    let onGround = true;
    let vy = 0;
    const gravity = 30;
    const jumpSpeed = 10;

    const clock = new THREE.Clock();

    function move(dt) {
      const forward = (keys.has('w') || keys.has('i')) ? 1 : (keys.has('s') || keys.has('k')) ? -1 : 0;
      const strafe  = (keys.has('a') || keys.has('j')) ? 1 : (keys.has('d') || keys.has('l')) ? -1 : 0;

      const dir = new THREE.Vector3();
      const yawDir = new THREE.Vector3(-Math.sin(yaw.rotation.y), 0, -Math.cos(yaw.rotation.y));
      const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), yawDir).normalize();
      dir.addScaledVector(yawDir, forward).addScaledVector(right, strafe).normalize();

      let curAccel = accel;
      let curMax = maxSpeed;
      if (keys.has('shift') || keys.has('shiftleft') || keys.has('shiftright')) {
        curAccel *= sprintMult;
        curMax *= sprintMult;
      }

      if (dir.lengthSq() > 0) {
        velocity.addScaledVector(dir, curAccel * dt);
      } else {
        const decel = Math.max(0, 1 - damping * dt);
        velocity.multiplyScalar(decel);
      }

      const v2 = new THREE.Vector2(velocity.x, velocity.z);
      if (v2.length() > curMax) {
        v2.setLength(curMax);
        velocity.x = v2.x; velocity.z = v2.y;
      }

      if (onGround) vy = 0;
      vy -= gravity * dt;
      if ((keys.has(' ') || keys.has('space')) && onGround) {
        vy = jumpSpeed;
        onGround = false;
      }

      player.position.x += velocity.x * dt;
      player.position.z += velocity.z * dt;
      player.position.y += vy * dt;

      if (player.position.y < 0) { player.position.y = 0; onGround = true; }
    }

    // --- Menu logic ---
    function showMenu() {
      menuScreen.style.display = "flex";
      document.exitPointerLock?.();
    }
    function hideMenu() {
      menuScreen.style.display = "none";
    }

    let menuVisible = true;
    showMenu();

    document.addEventListener('keydown', (e) => {
      if (e.key === "Escape") {
        menuVisible = !menuVisible;
        if (menuVisible) showMenu();
        else { hideMenu(); requestLock(); }
      }
    });

    btnResume.addEventListener('click', () => {
      hideMenu();
      menuVisible = false;
      requestLock();
    });
    btnQuit.addEventListener('click', () => {
      window.location.reload();
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function tick() {
      const dt = Math.min(0.05, clock.getDelta());
      if (!menuVisible) {
        updateArrowLook(dt);
        move(dt);
      }
      sun.position.set(player.position.x + 200, 300, player.position.z + 150);
      sun.target?.position.copy(player.position);
      renderer.render(scene, camera);
      debug.textContent = `pos: ${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}\n` +
                          `yaw: ${(THREE.MathUtils.radToDeg(yaw.rotation.y)%360).toFixed(1)}°  pitch: ${(THREE.MathUtils.radToDeg(pitch.rotation.x)).toFixed(1)}°`;
      requestAnimationFrame(tick);
    }
    // --- Spawn Assassin Character ---
let assassin;

const texLoader = new THREE.TextureLoader();
const assassinTexture = texLoader.load("Resources/models/characters/mr.assassin/default.png");

mtlLoader.load("Resources/models/characters/mr.assassin/default_Mr.assassin.mtl", (mtl) => {
  mtl.preload();
  mtl.materials.default.map = assassinTexture;

  objLoader.setMaterials(mtl);
  objLoader.load("Resources/models/characters/mr.assassin/default_Mr.assassin.obj", (obj) => {
    assassin = obj;
    assassin.position.set(77.8, 0, -1.1);
    assassin.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        child.material.map = assassinTexture;
      }
    });
    scene.add(assassin);
  });
});

// --- Make assassin face player each frame ---
function updateAssassin() {
  if (assassin) {
    assassin.lookAt(player.position);
  }
}

    tick();
  </script>
</body>
