<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unkown</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0e13;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden;}
    #ui{position:fixed;top:0;left:0;right:0;display:flex;align-items:center;justify-content:space-between;padding:10px 12px;pointer-events:none;z-index:5;}
    #hint{pointer-events:none;opacity:.9}
    #btnStart{pointer-events:auto;border:1px solid #374151;background:#111827;color:#e5e7eb;padding:8px 12px;border-radius:10px;cursor:pointer}
    #btnStart:hover{background:#0f172a}
    .crosshair{position:fixed;top:50%;left:50%;width:16px;height:16px;transform:translate(-50%,-50%);pointer-events:none;z-index:5}
    .crosshair::before,.crosshair::after{content:"";position:absolute;background:#e5e7eb}
    .crosshair::before{left:7px;top:0;width:2px;height:16px}
    .crosshair::after{top:7px;left:0;width:16px;height:2px}
    #debug{position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,.35);padding:8px 10px;border-radius:10px;font-size:12px;white-space:pre;pointer-events:none;z-index:5}
    #menuScreen{position:fixed;inset:0;background:url("Resources/menus.png") center/cover no-repeat;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:10}
    #menuScreen button{margin:10px;padding:12px 24px;font-size:18px;border:none;border-radius:10px;cursor:pointer;background:rgba(17,24,39,0.8);color:#e5e7eb}
    #menuScreen button:hover{background:rgba(31,41,55,0.9)}
  </style>
</head>
<body>
  <div id="ui">
    <div id="hint">WASD / IJKL to move · Mouse or Arrow Keys to look · Space to jump · Shift to sprint</div>
    <button id="btnStart">Click to focus mouse</button>
  </div>
  <div class="crosshair" aria-hidden="true"></div>
  <div id="debug"></div>

  <div id="menuScreen">
    <button id="btnResume">Continue</button>
    <button id="btnQuit">Quit</button>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

    // --- Basic Three.js setup ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

    const yaw = new THREE.Object3D();
    const pitch = new THREE.Object3D();
    yaw.position.set(0, 1.8, 0);
    yaw.add(pitch);
    pitch.add(camera);
    scene.add(yaw);

    // Lighting
    const hemi = new THREE.HemisphereLight(0xffffff, 0x88aaff, 0.4);
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(200, 300, 150);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    const objLoader = new OBJLoader();
    const mtlLoader = new MTLLoader();

    // --- Ground ---
    const groundSize = 512;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    for (let y = 0; y < 128; y++){
      for (let x = 0; x < 128; x++){
        const base = [29,130,56];
        const variation = (Math.random()*20)-10;
        const r = Math.max(0, Math.min(255, base[0]+variation));
        const g = Math.max(0, Math.min(255, base[1]+variation));
        const b = Math.max(0, Math.min(255, base[2]+variation));
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x,y,1,1);
      }
    }
    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.NearestFilter;
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(groundSize/16, groundSize/16);
    const groundMat = new THREE.MeshLambertMaterial({ map: tex });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- Trees ---
    const treeParent = new THREE.Group();
    scene.add(treeParent);
    function createTree(){
      const dummy = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,3,8), new THREE.MeshLambertMaterial({ color: 0x8b5a2b }));
      trunk.position.y = 1.5; trunk.castShadow = true;
      const leaves = new THREE.Mesh(new THREE.SphereGeometry(1.5,12,12), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
      leaves.position.y = 3.4; leaves.castShadow = true;
      dummy.add(trunk, leaves);
      return dummy;
    }
    function scatterTrees(proto){
      const tileSize = 16, step = tileSize*2, half = groundSize/2;
      for (let x = -half + step/2; x < half; x += step){
        for (let z = -half + step/2; z < half; z += step){
          for (let i = 0; i < 2; i++){
            const t = proto.clone();
            const jx = (Math.random()-0.5)*(step*0.6);
            const jz = (Math.random()-0.5)*(step*0.6);
            t.position.set(x + jx, 0, z + jz);
            treeParent.add(t);
          }
        }
      }
    }
    scatterTrees(createTree());

    // --- Player ---
    const player = new THREE.Group();
    player.position.set(0,0,0);
    scene.add(player);
    player.add(yaw);

    // --- Controls ---
    const keys = new Set();
    window.addEventListener('keydown', (e) => { keys.add(e.key.toLowerCase()); });
    window.addEventListener('keyup',   (e) => { keys.delete(e.key.toLowerCase()); });

    const velocity = new THREE.Vector3();
    const accel = 45, damping = 10, maxSpeed = 8, sprintMult = 1.7;

    const btnStart = document.getElementById('btnStart');
    const debug = document.getElementById('debug');
    const menuScreen = document.getElementById('menuScreen');
    const btnResume = document.getElementById('btnResume');
    const btnQuit = document.getElementById('btnQuit');

    const MOUSE_BASE = 0.002;
    const minecraftSensitivity122 = MOUSE_BASE * (122/100);

    let pointerLocked = false;
    function requestLock(){ renderer.domElement.requestPointerLock(); }
    document.addEventListener('pointerlockchange', () => { pointerLocked = document.pointerLockElement === renderer.domElement; });

    btnStart.addEventListener('click', () => { hideMenu(); requestLock(); btnStart.blur(); });

    document.addEventListener('mousemove', (e) => {
      if (!pointerLocked) return;
      yaw.rotation.y -= e.movementX * minecraftSensitivity122;
      pitch.rotation.x -= e.movementY * minecraftSensitivity122;
      pitch.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, pitch.rotation.x));
    });

    function updateArrowLook(dt){
      const lookSpeed = 1.5;
      if (keys.has('arrowleft'))  yaw.rotation.y += lookSpeed*dt;
      if (keys.has('arrowright')) yaw.rotation.y -= lookSpeed*dt;
      if (keys.has('arrowdown'))  pitch.rotation.x -= lookSpeed*dt;
      if (keys.has('arrowup'))    pitch.rotation.x += lookSpeed*dt;
      pitch.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, pitch.rotation.x));
    }

    let onGround = true, vy = 0;
    const gravity = 30, jumpSpeed = 10;
    const clock = new THREE.Clock();

    function move(dt){
      const forward = (keys.has('w')||keys.has('i')) ? 1 : (keys.has('s')||keys.has('k')) ? -1 : 0;
      const strafe  = (keys.has('a')||keys.has('j')) ? 1 : (keys.has('d')||keys.has('l')) ? -1 : 0;

      const dir = new THREE.Vector3();
      const yawDir = new THREE.Vector3(-Math.sin(yaw.rotation.y),0,-Math.cos(yaw.rotation.y));
      const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), yawDir).normalize();
      dir.addScaledVector(yawDir, forward).addScaledVector(right, strafe).normalize();

      let curAccel = accel, curMax = maxSpeed;
      if (keys.has('shift') || keys.has('shiftleft') || keys.has('shiftright')) { curAccel *= sprintMult; curMax *= sprintMult; }

      if (dir.lengthSq() > 0) velocity.addScaledVector(dir, curAccel * dt);
      else { const decel = Math.max(0, 1 - damping * dt); velocity.multiplyScalar(decel); }

      const v2 = new THREE.Vector2(velocity.x, velocity.z);
      if (v2.length() > curMax) { v2.setLength(curMax); velocity.x = v2.x; velocity.z = v2.y; }

      if (onGround) vy = 0;
      vy -= gravity * dt;
      if ((keys.has(' ') || keys.has('space')) && onGround) { vy = jumpSpeed; onGround = false; }

      player.position.x += velocity.x * dt;
      player.position.z += velocity.z * dt;
      player.position.y += vy * dt;

      if (player.position.y < 0) { player.position.y = 0; onGround = true; }
    }

    // Menu logic
    function showMenu(){ menuScreen.style.display = "flex"; document.exitPointerLock?.(); }
    function hideMenu(){ menuScreen.style.display = "none"; }

    let menuVisible = true;
    showMenu();

    document.addEventListener('keydown', (e) => {
      if (e.key === "Escape") {
        menuVisible = !menuVisible;
        if (menuVisible) showMenu();
        else { hideMenu(); requestLock(); }
      }
    });

    btnResume.addEventListener('click', () => { hideMenu(); menuVisible = false; requestLock(); });
    btnQuit.addEventListener('click', () => { window.location.reload(); });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Assassin (MTL+OBJ) + wave.json manual animation mapping ---
    let assassin = null;
    const ANIM_PATH = "Resources/animations/characters/mr.assassin/wave.json";
    const OBJ_MTL_PATH = "Resources/models/characters/mr.assassin/";
    const ANIM_BONE = "ArmL"; // the bone/mesh name in your exported OBJ that represents the arm
    const BOX_HALF = 1.5; // half-extent for a 3x3x3 box
    let animData = null; // parsed Blockbench animation for bones
    let playing = false;
    let playStart = 0;
    let playDuration = 0;
    let lastInside = false;

    // load wave.json (Blockbench format)
    fetch(ANIM_PATH).then(r => {
      if (!r.ok) throw new Error('wave.json fetch failed: ' + r.status);
      return r.json();
    }).then(json => {
      // We expect structure: { animations: { wave: { animation_length, bones: { ArmL: { rotation: {...}, position: {...} } } } } }
      try {
        const anims = json.animations;
        if (!anims) { console.warn("wave.json missing animations."); return; }
        const keys = Object.keys(anims);
        if (keys.length === 0) { console.warn("wave.json animations empty."); return; }
        const name = keys[0];
        const anim = anims[name];
        animData = anim; // store whole animation (we'll use bones)
        playDuration = anim.animation_length || 0;
        console.log("Loaded wave.json (Blockbench format) duration", playDuration);
      } catch (e) {
        console.warn("Failed to parse wave.json:", e);
      }
    }).catch(err => {
      console.warn("Could not load wave.json:", err);
    });

    // helper: build keyframe arrays for a bone (rotation & position)
    function buildBoneKeyframes(boneObj){
      // boneObj.rotation: { "0.0":[x,y,z], "0.75":[..], ... } (degrees)
      // boneObj.position: similar
      const rotMap = boneObj.rotation || {};
      const posMap = boneObj.position || {};
      const times = new Set([...Object.keys(rotMap).map(Number), ...Object.keys(posMap).map(Number)]);
      const timeArr = Array.from(times).sort((a,b)=>a-b);
      const rotKeys = [];
      const posKeys = [];
      for (const t of timeArr){
        // rotation -> quaternion
        if (rotMap.hasOwnProperty(String(t))){
          const r = rotMap[String(t)];
          const euler = new THREE.Euler(
            THREE.MathUtils.degToRad(r[0]),
            THREE.MathUtils.degToRad(r[1]),
            THREE.MathUtils.degToRad(r[2]),
            'XYZ'
          );
          const q = new THREE.Quaternion().setFromEuler(euler);
          rotKeys.push({ t, q });
        } else {
          rotKeys.push({ t, q: null });
        }
        if (posMap.hasOwnProperty(String(t))){
          const p = posMap[String(t)];
          posKeys.push({ t, v: new THREE.Vector3(p[0], p[1], p[2]) });
        } else {
          posKeys.push({ t, v: null });
        }
      }
      return { times: timeArr, rotKeys, posKeys };
    }

    // sample helpers
    function sampleQuaternion(keys, t){
      // keys: array of {t, q} sorted by t. q may be null for some time points. We find two surrounding keys with non-null q.
      if (keys.length === 0) return null;
      if (t <= keys[0].t) return keys[0].q ? keys[0].q.clone() : null;
      if (t >= keys[keys.length-1].t) return keys[keys.length-1].q ? keys[keys.length-1].q.clone() : null;
      // find interval
      for (let i=0;i<keys.length-1;i++){
        const a = keys[i], b = keys[i+1];
        if (a.q && b.q && t >= a.t && t <= b.t){
          const local = (t - a.t) / (b.t - a.t);
          return a.q.clone().slerp(b.q, local);
        }
      }
      // fallback: nearest previous with q
      for (let i=keys.length-1;i>=0;i--) if (keys[i].q) return keys[i].q.clone();
      return null;
    }
    function sampleVector(keys, t){
      if (keys.length === 0) return null;
      if (t <= keys[0].t) return keys[0].v ? keys[0].v.clone() : null;
      if (t >= keys[keys.length-1].t) return keys[keys.length-1].v ? keys[keys.length-1].v.clone() : null;
      for (let i=0;i<keys.length-1;i++){
        const a = keys[i], b = keys[i+1];
        if (a.v && b.v && t >= a.t && t <= b.t){
          const local = (t - a.t) / (b.t - a.t);
          return a.v.clone().lerp(b.v, local);
        }
      }
      for (let i=keys.length-1;i>=0;i--) if (keys[i].v) return keys[i].v.clone();
      return null;
    }

    // load MTL then OBJ
    mtlLoader.load(OBJ_MTL_PATH + "default_Mr.Assassin.mtl", (mtl) => {
      mtl.preload();
      objLoader.setMaterials(mtl);
      objLoader.load(OBJ_MTL_PATH + "default_Mr.Assassin.obj", (obj) => {
        assassin = obj;
        // place somewhere near player but visible; keep your original offset if you want
        assassin.position.set(5, 0, -3); // tweak as needed
        assassin.scale.set(1,1,1);

        assassin.traverse((child) => {
          if (child.isMesh){
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        scene.add(assassin);

        // prepare bone keyframes if anim data present
        if (animData && animData.bones && animData.bones[ANIM_BONE]){
          const boneKF = buildBoneKeyframes(animData.bones[ANIM_BONE]);
          assassin.userData._animBone = { name: ANIM_BONE, kf: boneKF, duration: playDuration || (boneKF.times[boneKF.times.length-1] || 0) };
          console.log("Prepared keyframes for", ANIM_BONE, assassin.userData._animBone);
        } else {
          // we'll also set up a listener: if animData arrives later, hook it
          assassin.userData._animBone = null;
        }
      }, undefined, (err) => {
        console.warn("Failed to load assassin OBJ:", err);
      });
    }, undefined, (err) => {
      console.warn("Failed to load assassin MTL:", err);
    });

    // If wave.json loads after the OBJ, hook them up:
    const hookAnimInterval = setInterval(()=> {
      if (!animData) return;
      if (assassin && (!assassin.userData || !assassin.userData._animBone)){
        if (animData.bones && animData.bones[ANIM_BONE]){
          const boneKF = buildBoneKeyframes(animData.bones[ANIM_BONE]);
          if (!assassin.userData) assassin.userData = {};
          assassin.userData._animBone = { name: ANIM_BONE, kf: boneKF, duration: playDuration || (boneKF.times[boneKF.times.length-1] || 0) };
          console.log("Late-hooked keyframes for", ANIM_BONE);
          clearInterval(hookAnimInterval);
        }
      }
    }, 200);

    // play animation manually on the named mesh
    function playBoneAnimationOnce(root, boneName){
      if (!root || !root.getObjectByName) return false;
      const node = root.getObjectByName(boneName);
      if (!node && root.children){
        // try find by case-insensitve match
        const found = root.getObjectByProperty && (root.getObjectByProperty('name', boneName) || root.getObjectByProperty('name', boneName.toLowerCase()));
        if (found) { node = found; }
      }
      const animInfo = root.userData && root.userData._animBone;
      if (!animInfo || animInfo.name !== boneName) return false;
      node._animState = { startTime: clock.getElapsedTime(), duration: animInfo.duration, kf: animInfo.kf };
      return true;
    }

    // update applied manual animation (interpolate per-frame)
    function updateManualAnimation(root){
      if (!root) return;
      const node = root.getObjectByName(ANIM_BONE);
      if (!node) return;
      const state = node._animState;
      if (!state) return;
      const elapsed = clock.getElapsedTime() - state.startTime;
      const t = Math.min(elapsed, state.duration);
      // sample rotation and position
      const q = sampleQuaternion(state.kf.rotKeys, t);
      const pos = sampleVector(state.kf.posKeys, t);
      if (q) {
        node.quaternion.copy(q);
      }
      if (pos) {
        node.position.copy(pos);
      }
      // finish condition
      if (elapsed >= state.duration){
        // clear state so it can be replayed on re-entry
        node._animState = null;
      }
    }

    // check 3x3x3 box around assassin: half extents BOX_HALF
    function checkProximityAndTrigger(){
      if (!assassin) return;
      const aPos = new THREE.Vector3();
      const pPos = new THREE.Vector3();
      assassin.getWorldPosition(aPos);
      player.getWorldPosition(pPos);
      const inside = Math.abs(pPos.x - aPos.x) <= BOX_HALF &&
                     Math.abs(pPos.y - aPos.y) <= BOX_HALF &&
                     Math.abs(pPos.z - aPos.z) <= BOX_HALF;
      if (inside && !lastInside){
        // entered
        lastInside = true;
        // play animation: create _animState on the bone node
        const hooked = assassin.userData && assassin.userData._animBone;
        if (hooked){
          // try to find node by name; Blockbench OBJ exports often set mesh names
          const node = assassin.getObjectByName(ANIM_BONE);
          if (!node){
            // attempt case-insensitive search
            const found = assassin.children.find(c => c.name && c.name.toLowerCase() === ANIM_BONE.toLowerCase());
            if (found) {
              found._animState = { startTime: clock.getElapsedTime(), duration: (assassin.userData._animBone.duration || state.duration), kf: assassin.userData._animBone.kf };
            } else {
              // fallback: try to animate root's first child (best-effort)
              const fallbackNode = assassin.children.length ? assassin.children[0] : null;
              if (fallbackNode && assassin.userData._animBone.kf){
                fallbackNode._animState = { startTime: clock.getElapsedTime(), duration: assassin.userData._animBone.duration, kf: assassin.userData._animBone.kf };
              } else {
                console.warn("No target node named", ANIM_BONE, "found to animate.");
              }
            }
          } else {
            node._animState = { startTime: clock.getElapsedTime(), duration: assassin.userData._animBone.duration, kf: assassin.userData._animBone.kf };
          }
        } else {
          console.log("Entered wave zone but animation keyframes not ready yet.");
        }
      } else if (!inside && lastInside){
        // exited
        lastInside = false;
      }
    }

    // updateAssassin lookAt as before
    function updateAssassin(){
      if (assassin) assassin.lookAt(player.position);
    }

    // main tick
    function tick(){
      const dt = Math.min(0.05, clock.getDelta());
      if (!menuVisible){
        updateArrowLook(dt);
        move(dt);
      }
      updateAssassin();

      // manual animation update for bone node
      if (assassin){
        // update any manual animation state on the bone node or fallback nodes
        const boneNode = assassin.getObjectByName(ANIM_BONE) || assassin.children[0];
        if (boneNode) updateManualAnimation(assassin); // this function finds node by ANIM_BONE inside assassin
      }

      // check trigger
      checkProximityAndTrigger();

      sun.position.set(player.position.x + 200, 300, player.position.z + 150);
      sun.target?.position.copy(player.position);
      renderer.render(scene, camera);

      debug.textContent =
        `pos: ${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}\n` +
        `yaw: ${(THREE.MathUtils.radToDeg(yaw.rotation.y)%360).toFixed(1)}°  pitch: ${(THREE.MathUtils.radToDeg(pitch.rotation.x)).toFixed(1)}°\n` +
        `waveReady: ${!!(animData && animData.bones && animData.bones[ANIM_BONE])}  inZone:${lastInside}`;

      requestAnimationFrame(tick);
    }
    tick();

  </script>
</body>
</html>
