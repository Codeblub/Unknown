<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Unkown</title>
  <link rel="icon" type="image/x-icon" href="Unkown.ico">

  <style>
    /* =====================================================
       PAGE + HUD STYLES (verbose for debugging)
    ===================================================== */

    html, body {
      height: 100%;
      margin: 0;
      background: #0b0e13;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      overflow: hidden;
    }

    #ui {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      pointer-events: none;
      z-index: 5;
    }

    #hint {
      pointer-events: none;
      opacity: 0.9;
    }

    #btnStart {
      pointer-events: auto;
      border: 1px solid #374151;
      background: #111827;
      color: #e5e7eb;
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
    }
    #btnStart:hover {
      background: #0f172a;
    }

    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 16px;
      height: 16px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 5;
    }
    .crosshair::before,
    .crosshair::after {
      content: "";
      position: absolute;
      background: #e5e7eb;
    }
    .crosshair::before {
      left: 7px;
      top: 0;
      width: 2px;
      height: 16px;
    }
    .crosshair::after {
      top: 7px;
      left: 0;
      width: 16px;
      height: 2px;
    }

    #debug {
      position: fixed;
      left: 10px;
      bottom: 10px;
      background: rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      white-space: pre;
      pointer-events: none;
      z-index: 5;
    }

    #menuScreen {
      position: fixed;
      inset: 0;
      background: url("Resources/menus.png") center/cover no-repeat;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    #menuScreen button {
      margin: 10px;
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background: rgba(17,24,39,0.8);
      color: #e5e7eb;
    }
    #menuScreen button:hover {
      background: rgba(31,41,55,0.9);
    }

    /* Interaction prompt */
    #interactPrompt {
      position: fixed;
      bottom: 18%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 18px;
      display: none;
      z-index: 6;
      pointer-events: none;
    }

    /* Dialogue box (simple, no external PNGs) */
    #dialogueBox {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: none;
      background: rgba(0,0,0,0.9);
      padding: 18px 22px;
      z-index: 7;
      color: #e5e7eb;
      font-size: 16px;
      box-sizing: border-box;
    }
    #dialogueBox .title {
      font-weight: 700;
      margin-bottom: 8px;
      font-size: 18px;
    }
    #dialogueBox .content {
      line-height: 1.4;
    }
  </style>
</head>
<body>

  <!-- UI -->
  <div id="ui">
    <div id="hint">WASD / IJKL to move · Mouse or Arrow Keys to look · Space to jump · Shift to sprint</div>
    <button id="btnStart">Click to focus mouse</button>
  </div>

  <!-- Crosshair + debug -->
  <div class="crosshair" aria-hidden="true"></div>
  <div id="debug"></div>

  <!-- Interact prompt + dialogue -->
  <div id="interactPrompt">Press E to Interact</div>

  <div id="dialogueBox" role="dialog" aria-hidden="true">
    <div class="title">Mr. Assassin</div>
    <div class="content" id="dialogueText">Hello Shade.</div>
  </div>

  <!-- Menu -->
  <div id="menuScreen">
    <button id="btnResume">Continue</button>
    <button id="btnQuit">Quit</button>
  </div>

  <!-- import map for modules -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <!-- main module -->
  <script type="module">
    import * as THREE from 'three';
    import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

    /* =====================================================
       RENDERER + SCENE + CAMERA
    ===================================================== */

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

    // yaw & pitch objects to control look
    const yaw = new THREE.Object3D();
    const pitch = new THREE.Object3D();
    yaw.position.set(0, 1.8, 0);
    yaw.add(pitch);
    pitch.add(camera);
    scene.add(yaw);

    /* =====================================================
       LIGHTING
    ===================================================== */

    const hemi = new THREE.HemisphereLight(0xffffff, 0x88aaff, 0.4);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(200, 300, 150);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    /* =====================================================
       LOADERS
    ===================================================== */

    const objLoader = new OBJLoader();
    const mtlLoader = new MTLLoader();

    /* =====================================================
       GROUND (procedural texture)
    ===================================================== */

    const groundSize = 512;
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, 1, 1);

    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');

    for (let y = 0; y < 128; y++) {
      for (let x = 0; x < 128; x++) {
        const base = [29, 130, 56];
        const variation = (Math.random() * 20) - 10;
        const r = Math.max(0, Math.min(255, base[0] + variation));
        const g = Math.max(0, Math.min(255, base[1] + variation));
        const b = Math.max(0, Math.min(255, base[2] + variation));
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.NearestFilter;
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(groundSize / 16, groundSize / 16);

    const groundMat = new THREE.MeshLambertMaterial({ map: tex });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    /* =====================================================
       TREES
    ===================================================== */

    const treeParent = new THREE.Group();
    scene.add(treeParent);

    function createTree() {
      const dummy = new THREE.Group();

      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.3, 3, 8),
        new THREE.MeshLambertMaterial({ color: 0x8b5a2b })
      );
      trunk.position.y = 1.5;
      trunk.castShadow = true;

      const leaves = new THREE.Mesh(
        new THREE.SphereGeometry(1.5, 12, 12),
        new THREE.MeshLambertMaterial({ color: 0x2e7d32 })
      );
      leaves.position.y = 3.4;
      leaves.castShadow = true;

      dummy.add(trunk, leaves);
      return dummy;
    }

    function scatterTrees(proto) {
      const tileSize = 16;
      const step = tileSize * 2;
      const half = groundSize / 2;

      for (let x = -half + step/2; x < half; x += step) {
        for (let z = -half + step/2; z < half; z += step) {
          for (let i = 0; i < 2; i++) {
            const t = proto.clone();
            const jx = (Math.random() - 0.5) * (step * 0.6);
            const jz = (Math.random() - 0.5) * (step * 0.6);
            t.position.set(x + jx, 0, z + jz);
            treeParent.add(t);
          }
        }
      }
    }

    scatterTrees(createTree());

    /* =====================================================
       PLAYER (group used as actor)
    ===================================================== */

    const player = new THREE.Group();
    player.position.set(0, 0, 0);
    scene.add(player);
    player.add(yaw);

    /* =====================================================
       CONTROLS
    ===================================================== */

    const keys = new Set();

    window.addEventListener('keydown', (e) => {
      keys.add(e.key.toLowerCase());
    });

    window.addEventListener('keyup', (e) => {
      keys.delete(e.key.toLowerCase());
    });

    const velocity = new THREE.Vector3();
    const accel = 45;
    const damping = 10;
    const maxSpeed = 8;
    const sprintMult = 1.7;

    const btnStart = document.getElementById('btnStart');
    const debug = document.getElementById('debug');
    const menuScreen = document.getElementById('menuScreen');
    const btnResume = document.getElementById('btnResume');
    const btnQuit = document.getElementById('btnQuit');

    const MOUSE_BASE = 0.002;
    const minecraftSensitivity122 = MOUSE_BASE * (122 / 100);

    let pointerLocked = false;

    function requestLock() {
      renderer.domElement.requestPointerLock();
    }

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === renderer.domElement;
    });

    btnStart.addEventListener('click', () => {
      hideMenu();
      requestLock();
      btnStart.blur();
    });

    document.addEventListener('mousemove', (e) => {
      if (!pointerLocked) return;
      yaw.rotation.y -= e.movementX * minecraftSensitivity122;
      pitch.rotation.x -= e.movementY * minecraftSensitivity122;
      pitch.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, pitch.rotation.x));
    });

    /* =====================================================
       MOVEMENT + PHYSICS
    ===================================================== */

    function updateArrowLook(dt) {
      const lookSpeed = 1.5;
      if (keys.has('arrowleft'))  yaw.rotation.y += lookSpeed * dt;
      if (keys.has('arrowright')) yaw.rotation.y -= lookSpeed * dt;
      if (keys.has('arrowdown'))  pitch.rotation.x -= lookSpeed * dt;
      if (keys.has('arrowup'))    pitch.rotation.x += lookSpeed * dt;
      pitch.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, pitch.rotation.x));
    }

    let onGround = true;
    let vy = 0;
    const gravity = 30;
    const jumpSpeed = 10;

    const clock = new THREE.Clock();

    function move(dt) {
      const forward = (keys.has('w') || keys.has('i')) ? 1 : (keys.has('s') || keys.has('k')) ? -1 : 0;
      const strafe  = (keys.has('a') || keys.has('j')) ? 1 : (keys.has('d') || keys.has('l')) ? -1 : 0;

      const dir = new THREE.Vector3();
      const yawDir = new THREE.Vector3(-Math.sin(yaw.rotation.y), 0, -Math.cos(yaw.rotation.y));
      const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), yawDir).normalize();

      dir.addScaledVector(yawDir, forward).addScaledVector(right, strafe).normalize();

      let curAccel = accel;
      let curMax = maxSpeed;

      if (keys.has('shift') || keys.has('shiftleft') || keys.has('shiftright')) {
        curAccel *= sprintMult;
        curMax *= sprintMult;
      }

      if (dir.lengthSq() > 0) {
        velocity.addScaledVector(dir, curAccel * dt);
      } else {
        const decel = Math.max(0, 1 - damping * dt);
        velocity.multiplyScalar(decel);
      }

      const v2 = new THREE.Vector2(velocity.x, velocity.z);
      if (v2.length() > curMax) {
        v2.setLength(curMax);
        velocity.x = v2.x;
        velocity.z = v2.y;
      }

      // gravity & jump
      if (onGround) vy = 0;
      vy -= gravity * dt;
      if ((keys.has(' ') || keys.has('space')) && onGround) {
        vy = jumpSpeed;
        onGround = false;
      }

      // integrate
      player.position.x += velocity.x * dt;
      player.position.z += velocity.z * dt;
      player.position.y += vy * dt;

      // ground collision
      if (player.position.y < 0) {
        player.position.y = 0;
        onGround = true;
      }
    }

    /* =====================================================
       MENU LOGIC
    ===================================================== */

    function showMenu() {
      menuScreen.style.display = "flex";
      document.exitPointerLock?.();
    }

    function hideMenu() {
      menuScreen.style.display = "none";
    }

    let menuVisible = true;
    showMenu();

    document.addEventListener('keydown', (e) => {
      if (e.key === "Escape") {
        menuVisible = !menuVisible;
        if (menuVisible) showMenu();
        else { hideMenu(); requestLock(); }
      }
    });

    btnResume.addEventListener('click', () => {
      hideMenu();
      menuVisible = false;
      requestLock();
    });

    btnQuit.addEventListener('click', () => {
      window.location.reload();
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /* =====================================================
       WAVE JSON LOADER -> try to convert into THREE.AnimationClip
       (graceful if file format is different)
    ===================================================== */

    const fileLoader = new THREE.FileLoader();
    fileLoader.setResponseType('json');

    let waveClip = null;

    fileLoader.load(
      "Resources/animations/characters/mr.assassin/wave.json",
      (json) => {
        try {
          let clips = [];

          if (json && json.animations && Array.isArray(json.animations) && json.animations.length > 0) {
            clips = json.animations.map(a => THREE.AnimationClip.parse(a));
          } else if (Array.isArray(json) && json.length > 0) {
            clips = json.map(a => THREE.AnimationClip.parse(a));
          } else if (json && (json.tracks || json.name)) {
            clips = [THREE.AnimationClip.parse(json)];
          }

          if (clips.length > 0) {
            waveClip = clips[0];
            console.log('wave.json loaded, clip:', waveClip.name || waveClip);
          } else {
            console.warn('wave.json loaded but no clips found (unexpected format).', json);
          }
        } catch (err) {
          console.warn('Failed to parse wave.json into AnimationClip:', err);
        }
      },
      undefined,
      (err) => {
        console.warn('Could not load wave.json (404 or network error).', err);
      }
    );

    /* =====================================================
       ASSASSIN: load OBJ, apply texture, prepare mixer/action
    ===================================================== */

    let assassin = null;

    const texLoader = new THREE.TextureLoader();
    const assassinTexture = texLoader.load("Resources/models/characters/mr.assassin/default.png");
    assassinTexture.magFilter = THREE.NearestFilter;
    assassinTexture.minFilter = THREE.NearestFilter;

    let playerInWaveZone = false;
    const waveBoxHalf = 1.5; // half-extent for 3x3x3 trigger

    objLoader.load(
      "Resources/models/characters/mr.assassin/default_Mr.Assassin.obj",
      (obj) => {
        assassin = obj;

        // default position & orientation
        assassin.position.set(77.8, 0, -1.1);
        assassin.rotation.y = Math.PI;

        // ensure meshes get the texture & shadows
        assassin.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            child.material = new THREE.MeshLambertMaterial({ map: assassinTexture });
          }
        });

        assassin.scale.set(1, 1, 1);

        // animation mixer attached to assassin for wave play
        const mixer = new THREE.AnimationMixer(assassin);
        assassin.userData.mixer = mixer;

        if (waveClip) {
          try {
            const action = mixer.clipAction(waveClip);
            action.setLoop(THREE.LoopOnce, 0);
            action.clampWhenFinished = true;
            assassin.userData.waveAction = action;
          } catch (err) {
            console.warn('Failed to create wave action (clip mismatch?).', err);
            assassin.userData.waveAction = null;
          }
        } else {
          assassin.userData.waveAction = null;
        }

        scene.add(assassin);
      },
      undefined,
      (err) => {
        console.warn("Failed to load assassin OBJ:", err);
      }
    );

    /* =====================================================
       If waveClip loads *after* assassin, hook it up (poll)
    ===================================================== */

    function tryHookWaveClip() {
      if (!waveClip || !assassin) return;

      if (!assassin.userData) assassin.userData = {};
      if (!assassin.userData.mixer) assassin.userData.mixer = new THREE.AnimationMixer(assassin);

      if (!assassin.userData.waveAction) {
        try {
          const action = assassin.userData.mixer.clipAction(waveClip);
          action.setLoop(THREE.LoopOnce, 0);
          action.clampWhenFinished = true;
          assassin.userData.waveAction = action;
          console.log('waveClip hooked to assassin after late load.');
        } catch (err) {
          console.warn('Failed to hook waveClip to assassin:', err);
        }
      }
    }

    const hookInterval = setInterval(() => {
      tryHookWaveClip();

      // stop polling once we have both assassin & action
      if (assassin && assassin.userData && assassin.userData.waveAction) {
        clearInterval(hookInterval);
      }
    }, 200);

    /* =====================================================
       CHECK PROXIMITY, TRIGGER WAVE, AND SHOW PROMPT
    ===================================================== */

    const interactPromptEl = document.getElementById('interactPrompt');
    const dialogueBoxEl = document.getElementById('dialogueBox');
    const dialogueTextEl = document.getElementById('dialogueText');

    let dialogueOpen = false;

    function checkWaveTrigger() {
      if (!assassin) {
        // ensure prompt hidden when assassin not present
        interactPromptEl.style.display = 'none';
        return;
      }

      // world positions
      const aPos = new THREE.Vector3();
      const pPos = new THREE.Vector3();
      assassin.getWorldPosition(aPos);
      player.getWorldPosition(pPos);

      // axis-aligned 3x3x3 cube check
      const inside =
        Math.abs(pPos.x - aPos.x) <= waveBoxHalf &&
        Math.abs(pPos.y - aPos.y) <= waveBoxHalf &&
        Math.abs(pPos.z - aPos.z) <= waveBoxHalf;

      // show the interaction prompt if inside and dialog not open
      if (inside && !dialogueOpen) {
        interactPromptEl.style.display = 'block';
      } else {
        interactPromptEl.style.display = 'none';
      }

      // wave trigger logic (retrigger on re-enter)
      if (inside && !playerInWaveZone) {
        // player just entered
        playerInWaveZone = true;

        const action = assassin.userData?.waveAction;
        if (action) {
          try {
            action.reset();
            action.play();
          } catch (err) {
            console.warn('Failed to play wave action:', err);
          }
        } else {
          // action not ready yet
          console.log('Entered wave zone but wave action not ready yet.');
        }
      } else if (!inside && playerInWaveZone) {
        // left
        playerInWaveZone = false;

        // if dialogue was open, close it when leaving
        if (dialogueOpen) {
          dialogueBoxEl.style.display = 'none';
          dialogueOpen = false;
        }
      }
    }

    /* =====================================================
       INTERACTION (E to open, Esc to close)
    ===================================================== */

    document.addEventListener('keydown', (e) => {
      // Open dialogue with E if prompt visible
      if (e.key.toLowerCase() === 'e') {
        if (interactPromptEl.style.display === 'block' && !dialogueOpen) {
          dialogueBoxEl.style.display = 'block';
          dialogueOpen = true;
        }
      }

      // close dialogue with Escape
      if (e.key === 'Escape' && dialogueOpen) {
        dialogueBoxEl.style.display = 'none';
        dialogueOpen = false;
      }
    });

    /* =====================================================
       ASSASSIN LOOK AT PLAYER (optional, kept short)
    ===================================================== */

    function updateAssassinLook() {
      if (!assassin) return;
      assassin.lookAt(player.position);
    }

    /* =====================================================
       MAIN TICK / ANIMATION LOOP
    ===================================================== */

    function tick() {
      const dt = Math.min(0.05, clock.getDelta());

      // movement + look updates while menu hidden
      if (!menuVisible) {
        updateArrowLook(dt);
        move(dt);
      }

      // assassin look
      updateAssassinLook();

      // update mixer
      if (assassin && assassin.userData && assassin.userData.mixer) {
        assassin.userData.mixer.update(dt);
      }

      // proximity & interaction prompt & wave trigger
      checkWaveTrigger();

      // move sun relative to player for consistent lighting angle
      sun.position.set(player.position.x + 200, 300, player.position.z + 150);
      sun.target?.position.copy(player.position);

      // rendering
      renderer.render(scene, camera);

      // debug text
      debug.textContent =
        `pos: ${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}\n` +
        `yaw: ${(THREE.MathUtils.radToDeg(yaw.rotation.y) % 360).toFixed(1)}°  pitch: ${(THREE.MathUtils.radToDeg(pitch.rotation.x)).toFixed(1)}°\n` +
        `waveZone: ${playerInWaveZone ? 'IN' : 'OUT'}  dialogue: ${dialogueOpen ? 'OPEN' : 'CLOSED'}`;

      requestAnimationFrame(tick);
    }

    tick();

    /* =====================================================
       READY LOGS (small helper)
    ===================================================== */

    console.log('Scene initialized. Player is at (0,0,0).');

  </script>
</body>
</html>
