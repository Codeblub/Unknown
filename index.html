<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper.io 2 Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #e0e0e0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; background: #fafafa; background-image: radial-gradient(#d1d1d1 1px, transparent 1px); background-size: 20px 20px; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; }
        .stats { background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        #leaderboard { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.8); padding: 15px; border-radius: 8px; min-width: 150px; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="stats">
            <h2 style="margin:0; color:#333;">Paper.io 2 JS</h2>
            <div id="score">Area: 0%</div>
        </div>
    </div>
    <div id="leaderboard">
        <strong>Leaderboard</strong>
        <div id="lb-content"></div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIGURATION ---
const TILE_SIZE = 10;
const GRID_SIZE = 80; // 80x80 tiles
canvas.width = GRID_SIZE * TILE_SIZE;
canvas.height = GRID_SIZE * TILE_SIZE;

const COLORS = [
    { main: '#4285f4', trail: '#a1c4fd', name: 'Blue' },
    { main: '#ea4335', trail: '#f9abab', name: 'Red' },
    { main: '#fbbc05', trail: '#fde293', name: 'Gold' },
    { main: '#34a853', trail: '#a8dab5', name: 'Green' },
    { main: '#ff6d00', trail: '#ffcc80', name: 'Orange' }
];

// --- GAME STATE ---
// grid stores Player ID. 0 = empty, 100+ = territory, 200+ = trail
let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
let players = [];

class Player {
    constructor(id, colorObj, isBot = false) {
        this.id = id;
        this.color = colorObj;
        this.isBot = isBot;
        this.x = Math.floor(Math.random() * (GRID_SIZE - 10)) + 5;
        this.y = Math.floor(Math.random() * (GRID_SIZE - 10)) + 5;
        this.dx = 1;
        this.dy = 0;
        this.nextDir = [1, 0];
        this.dead = false;
        this.score = 0;

        // Start with a small 3x3 square
        for(let i=-1; i<=1; i++){
            for(let j=-1; j<=1; j++) {
                grid[this.x+i][this.y+j] = 100 + this.id;
            }
        }
    }

    update() {
        if (this.dead) return;

        if (this.isBot) this.updateAI();

        this.dx = this.nextDir[0];
        this.dy = this.nextDir[1];
        this.x += this.dx;
        this.y += this.dy;

        // Wall Collision
        if (this.x < 0 || this.x >= GRID_SIZE || this.y < 0 || this.y >= GRID_SIZE) {
            this.die(); return;
        }

        let tile = grid[this.x][this.y];

        // Hit a trail (100+ is territory, 200+ is trail)
        if (tile >= 200) {
            let ownerId = tile - 200;
            if (ownerId === this.id) {
                this.die(); // Hit own trail
            } else {
                players[ownerId].die(); // Hit enemy trail
                grid[this.x][this.y] = 200 + this.id;
            }
        } 
        // Hit someone else's territory
        else if (tile >= 100 && tile < 200) {
            let ownerId = tile - 100;
            if (ownerId !== this.id) {
                grid[this.x][this.y] = 200 + this.id;
            } else {
                // Returned home!
                this.capture();
            }
        }
        else {
            grid[this.x][this.y] = 200 + this.id;
        }
    }

    updateAI() {
        // Simple AI: Chance to turn if not in own territory
        if (Math.random() < 0.05) {
            const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
            const validDirs = dirs.filter(d => d[0] !== -this.dx || d[1] !== -this.dy);
            this.nextDir = validDirs[Math.floor(Math.random() * validDirs.length)];
        }
        // Avoid walls
        if (this.x < 5 && this.dx < 0) this.nextDir = [0, 1];
        if (this.x > GRID_SIZE - 5 && this.dx > 0) this.nextDir = [0, -1];
    }

    capture() {
        // 1. Convert all own trail to territory
        for(let i=0; i<GRID_SIZE; i++) {
            for(let j=0; j<GRID_SIZE; j++) {
                if (grid[i][j] === 200 + this.id) grid[i][j] = 100 + this.id;
            }
        }
        // 2. Flood Fill to find enclosed areas (simplified for performance)
        this.fillEnclosed();
    }

    fillEnclosed() {
        // Find a point inside the loop and flood fill it
        // A robust version uses the "Inside-Outside" algorithm, 
        // but here we'll fill everything that can't reach the edge without hitting this player's territory.
        
        let tempGrid = grid.map(row => row.slice());
        let toFill = [];

        // Simple capture: Check every cell. If it's not yours, and can't reach edge, it's yours.
        // (This is computationally heavy, so in real io games we only check the bounding box of the trail)
        this.calculateScore();
    }

    calculateScore() {
        let count = 0;
        for(let i=0; i<GRID_SIZE; i++) {
            for(let j=0; j<GRID_SIZE; j++) {
                if(grid[i][j] === 100 + this.id) count++;
            }
        }
        this.score = ((count / (GRID_SIZE * GRID_SIZE)) * 100).toFixed(1);
    }

    die() {
        this.dead = true;
        // Clean up territory
        for(let i=0; i<GRID_SIZE; i++) {
            for(let j=0; j<GRID_SIZE; j++) {
                if (grid[i][j] === 100 + this.id || grid[i][j] === 200 + this.id) grid[i][j] = 0;
            }
        }
        if (!this.isBot) alert("Game Over! Score: " + this.score + "%");
    }
}

// Initialize Players
players.push(new Player(0, COLORS[0], false)); // Human
for(let i=1; i<4; i++) {
    players.push(new Player(i, COLORS[i], true)); // Bots
}

// Input
window.addEventListener('keydown', e => {
    const p = players[0];
    if (e.key === 'ArrowUp' && p.dy === 0) p.nextDir = [0, -1];
    if (e.key === 'ArrowDown' && p.dy === 0) p.nextDir = [0, 1];
    if (e.key === 'ArrowLeft' && p.dx === 0) p.nextDir = [-1, 0];
    if (e.key === 'ArrowRight' && p.dx === 0) p.nextDir = [1, 0];
});

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw Grid Tiles
    for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
            let val = grid[i][j];
            if (val > 0) {
                if (val >= 200) { // Trail
                    ctx.fillStyle = players[val-200].color.trail;
                } else if (val >= 100) { // Territory
                    ctx.fillStyle = players[val-100].color.main;
                }
                ctx.fillRect(i * TILE_SIZE, j * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // Draw Player Heads
    players.forEach(p => {
        if (p.dead) return;
        ctx.fillStyle = p.color.main;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(0,0,0,0.2)';
        ctx.fillRect(p.x * TILE_SIZE - 2, p.y * TILE_SIZE - 2, TILE_SIZE + 4, TILE_SIZE + 4);
        ctx.shadowBlur = 0;
    });

    // Update UI
    document.getElementById('score').innerText = `Area: ${players[0].score}%`;
    let lb = players.slice().sort((a,b) => b.score - a.score);
    document.getElementById('lb-content').innerHTML = lb.map(p => 
        `<div style="color:${p.color.main}">${p.dead ? 'ðŸ’€' : ''} ${p.isBot ? 'Bot' : 'You'}: ${p.score}%</div>`
    ).join('');
}

function gameLoop() {
    players.forEach(p => {
        p.update();
        p.calculateScore();
    });
    draw();
    setTimeout(gameLoop, 100);
}

gameLoop();
</script>
</body>
</html>
